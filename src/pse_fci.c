/* Generated by autober: do not modify */
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include "ber.h"
#include "autober.h"
#include "pse_fci.h"

/* Tags for root level */
static const struct autober_tag root_tags[] = {
	{.ab_label = "File Control Information",
		.ab_flags = AUTOBER_TEMPLATE,
		.ab_tag = TAG_PSE_FCI},
};

/* Tags for File Control Information */
static const struct autober_tag pse_fci_tags[] = {
	{.ab_label = "Payment System Directory ADF",
		.ab_flags = AUTOBER_TEMPLATE,
		.ab_tag = TAG_PSE_FCI_PSE_APP},
};

/* Tags for Payment System Directory ADF */
static const struct autober_tag pse_app_tags[] = {
	{.ab_label = "pse_adf_name",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_CHECK_SIZE,
		.ab_size = {5, 16},
		.ab_tag = TAG_PSE_APP_PSE_ADF_NAME},
	{.ab_label = "pse_label",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_PSE_APP_PSE_LABEL},
	{.ab_label = "pse_prio",
		.ab_type = AUTOBER_TYPE_INT,
		.ab_flags = AUTOBER_CHECK_SIZE,
		.ab_size = {1, 1},
		.ab_tag = TAG_PSE_APP_PSE_PRIO},
	{.ab_label = "pse_pname",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_PSE_APP_PSE_PNAME},
};

static void _free_pse_app(struct pse_app *pse_app)
{
}

static void _free_pse_fci(struct pse_fci *pse_fci)
{
	if ( NULL == pse_fci )
		return;

	_free_pse_app(&pse_fci->pse_app);
	free(pse_fci);
}

void pse_fci_free(struct pse_fci *pse_fci)
{
	_free_pse_fci(pse_fci);
}

static int _pse_app(struct pse_app *pse_app,
				const uint8_t *ptr, size_t len)
{
	static const unsigned int num = AUTOBER_NUM_TAGS(pse_app_tags);
	struct autober_constraint cons[num];
	struct gber_tag tag;
	const uint8_t *end;

	if ( !autober_constraints(pse_app_tags, cons, num, ptr, len) ) {
		fprintf(stderr, "pse_app_tags: constraints not satisified\n");
		return 0;
	}

	for(end = ptr + len; ptr < end; ptr += tag.ber_len) {
		ptr = ber_decode_tag(&tag, ptr, end - ptr);
		if ( NULL == ptr )
			return 0;

		switch(tag.ber_tag) {
		case TAG_PSE_APP_PSE_ADF_NAME:
			if ( !autober_octet(pse_app->pse_adf_name, &tag, ptr, &pse_app->_pse_adf_name_count) )
				return 0;
			break;
		case TAG_PSE_APP_PSE_LABEL:
			if ( !autober_octet(pse_app->pse_label, &tag, ptr, &pse_app->_pse_label_count) )
				return 0;
			break;
		case TAG_PSE_APP_PSE_PNAME:
			if ( !autober_octet(pse_app->pse_pname, &tag, ptr, &pse_app->_pse_pname_count) )
				return 0;
			pse_app->_present |= PSE_APP_PSE_PNAME;
			break;
		case TAG_PSE_APP_PSE_PRIO:
			if ( !autober_u8(&pse_app->pse_prio, &tag, ptr, NULL) )
				return 0;
			break;
		default:
			fprintf(stderr, "Unexpected tag: Payment System Directory ADF: 0x%x\n", tag.ber_tag);
			continue;
		}
	}

	return 1;
}

static int _pse_fci(struct pse_fci *pse_fci,
				const uint8_t *ptr, size_t len)
{
	static const unsigned int num = AUTOBER_NUM_TAGS(pse_fci_tags);
	struct autober_constraint cons[num];
	struct gber_tag tag;
	const uint8_t *end;

	if ( !autober_constraints(pse_fci_tags, cons, num, ptr, len) ) {
		fprintf(stderr, "pse_fci_tags: constraints not satisified\n");
		return 0;
	}

	for(end = ptr + len; ptr < end; ptr += tag.ber_len) {
		ptr = ber_decode_tag(&tag, ptr, end - ptr);
		if ( NULL == ptr )
			return 0;

		switch(tag.ber_tag) {
		case TAG_PSE_FCI_PSE_APP:
			if ( !_pse_app(&pse_fci->pse_app, ptr, tag.ber_len) )
				return 0;
			break;
		default:
			fprintf(stderr, "Unexpected tag: File Control Information: 0x%x\n", tag.ber_tag);
			continue;
		}
	}

	return 1;
}

static int _root(struct pse_fci *pse_fci,
				const uint8_t *ptr, size_t len)
{
	static const unsigned int num = AUTOBER_NUM_TAGS(root_tags);
	struct autober_constraint cons[num];
	struct gber_tag tag;
	const uint8_t *end;

	if ( !autober_constraints(root_tags, cons, num, ptr, len) ) {
		fprintf(stderr, "root_tags: constraints not satisified\n");
		return 0;
	}

	for(end = ptr + len; ptr < end; ptr += tag.ber_len) {
		ptr = ber_decode_tag(&tag, ptr, end - ptr);
		if ( NULL == ptr )
			return 0;

		switch(tag.ber_tag) {
		case TAG_PSE_FCI:
			if ( !_pse_fci(pse_fci, ptr, tag.ber_len) )
				return 0;
			break;
		default:
			fprintf(stderr, "Unexpected tag: root level: 0x%x\n", tag.ber_tag);
			continue;
		}
	}

	return 1;
}

struct pse_fci *pse_fci_decode(const uint8_t *ptr, size_t len)
{
	struct pse_fci *pse_fci;

	pse_fci = calloc(1, sizeof(*pse_fci));
	if ( NULL == pse_fci )
		return NULL;

	if ( !_root(pse_fci, ptr, len) ) {
		_free_pse_fci(pse_fci);
		return NULL;
	}

	return pse_fci;
}
