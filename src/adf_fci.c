/* Generated by autober: do not modify */
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include "ber.h"
#include "autober.h"
#include "adf_fci.h"

/* Tags for root level */
static const struct autober_tag root_tags[] = {
	{.ab_label = "File Control Information",
		.ab_flags = AUTOBER_TEMPLATE,
		.ab_tag = TAG_ADF_FCI},
};

/* Tags for File Control Information */
static const struct autober_tag adf_fci_tags[] = {
	{.ab_label = "df_name",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_CHECK_SIZE,
		.ab_size = {5, 16},
		.ab_tag = TAG_ADF_FCI_DF_NAME},
	{.ab_label = "FCI Proprietary Template",
		.ab_flags = AUTOBER_TEMPLATE,
		.ab_tag = TAG_ADF_FCI_ADF},
};

/* Tags for FCI Proprietary Template */
static const struct autober_tag adf_tags[] = {
	{.ab_label = "label",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_ADF_LABEL},
	{.ab_label = "prio",
		.ab_type = AUTOBER_TYPE_INT,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 1},
		.ab_tag = TAG_ADF_PRIO},
	{.ab_label = "language",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_ADF_LANGUAGE},
	{.ab_label = "issuer_code",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_ADF_ISSUER_CODE},
	{.ab_label = "pname",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_ADF_PNAME},
	{.ab_label = "pdol",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_ADF_PDOL},
	{.ab_label = "FCI Issuer Discretionary Data",
		.ab_flags = AUTOBER_TEMPLATE|AUTOBER_OPTIONAL,
		.ab_tag = TAG_ADF_FCI_IDD},
};

/* Tags for FCI Issuer Discretionary Data */
static const struct autober_tag fci_idd_tags[] = {
	{.ab_label = "log_entry",
		.ab_type = AUTOBER_TYPE_OCTET,
		.ab_flags = AUTOBER_OPTIONAL|AUTOBER_CHECK_SIZE,
		.ab_size = {1, 16},
		.ab_tag = TAG_FCI_IDD_LOG_ENTRY},
};

static void _free_fci_idd(struct fci_idd *fci_idd)
{
}

static void _free_adf(struct adf *adf)
{
	if ( adf->_present & ADF_FCI_IDD )
		_free_fci_idd(&adf->fci_idd);
}

static void _free_adf_fci(struct adf_fci *adf_fci)
{
	if ( NULL == adf_fci )
		return;

	_free_adf(&adf_fci->adf);
	free(adf_fci);
}

void adf_fci_free(struct adf_fci *adf_fci)
{
	_free_adf_fci(adf_fci);
}

static int _fci_idd(struct fci_idd *fci_idd,
				const uint8_t *ptr, size_t len)
{
	static const unsigned int num = AUTOBER_NUM_TAGS(fci_idd_tags);
	struct autober_constraint cons[num];
	struct gber_tag tag;
	const uint8_t *end;

	if ( !autober_constraints(fci_idd_tags, cons, num, ptr, len) ) {
		fprintf(stderr, "fci_idd_tags: constraints not satisified\n");
		return 0;
	}

	for(end = ptr + len; ptr < end; ptr += tag.ber_len) {
		ptr = ber_decode_tag(&tag, ptr, end - ptr);
		if ( NULL == ptr )
			return 0;

		switch(tag.ber_tag) {
		case TAG_FCI_IDD_LOG_ENTRY:
			if ( !autober_octet(fci_idd->log_entry, &tag, ptr, &fci_idd->_log_entry_count) )
				return 0;
			fci_idd->_present |= FCI_IDD_LOG_ENTRY;
			break;
		default:
			fprintf(stderr, "Unexpected tag: FCI Issuer Discretionary Data: 0x%x\n", tag.ber_tag);
			continue;
		}
	}

	return 1;
}

static int _adf(struct adf *adf,
				const uint8_t *ptr, size_t len)
{
	static const unsigned int num = AUTOBER_NUM_TAGS(adf_tags);
	struct autober_constraint cons[num];
	struct gber_tag tag;
	const uint8_t *end;

	if ( !autober_constraints(adf_tags, cons, num, ptr, len) ) {
		fprintf(stderr, "adf_tags: constraints not satisified\n");
		return 0;
	}

	for(end = ptr + len; ptr < end; ptr += tag.ber_len) {
		ptr = ber_decode_tag(&tag, ptr, end - ptr);
		if ( NULL == ptr )
			return 0;

		switch(tag.ber_tag) {
		case TAG_ADF_LABEL:
			if ( !autober_octet(adf->label, &tag, ptr, &adf->_label_count) )
				return 0;
			adf->_present |= ADF_LABEL;
			break;
		case TAG_ADF_PRIO:
			if ( !autober_u8(&adf->prio, &tag, ptr, NULL) )
				return 0;
			adf->_present |= ADF_PRIO;
			break;
		case TAG_ADF_PDOL:
			if ( !autober_octet(adf->pdol, &tag, ptr, &adf->_pdol_count) )
				return 0;
			adf->_present |= ADF_PDOL;
			break;
		case TAG_ADF_LANGUAGE:
			if ( !autober_octet(adf->language, &tag, ptr, &adf->_language_count) )
				return 0;
			adf->_present |= ADF_LANGUAGE;
			break;
		case TAG_ADF_ISSUER_CODE:
			if ( !autober_octet(adf->issuer_code, &tag, ptr, &adf->_issuer_code_count) )
				return 0;
			adf->_present |= ADF_ISSUER_CODE;
			break;
		case TAG_ADF_PNAME:
			if ( !autober_octet(adf->pname, &tag, ptr, &adf->_pname_count) )
				return 0;
			adf->_present |= ADF_PNAME;
			break;
		case TAG_ADF_FCI_IDD:
			if ( !_fci_idd(&adf->fci_idd, ptr, tag.ber_len) )
				return 0;
			adf->_present |= ADF_FCI_IDD;
			break;
		default:
			fprintf(stderr, "Unexpected tag: FCI Proprietary Template: 0x%x\n", tag.ber_tag);
			continue;
		}
	}

	return 1;
}

static int _adf_fci(struct adf_fci *adf_fci,
				const uint8_t *ptr, size_t len)
{
	static const unsigned int num = AUTOBER_NUM_TAGS(adf_fci_tags);
	struct autober_constraint cons[num];
	struct gber_tag tag;
	const uint8_t *end;

	if ( !autober_constraints(adf_fci_tags, cons, num, ptr, len) ) {
		fprintf(stderr, "adf_fci_tags: constraints not satisified\n");
		return 0;
	}

	for(end = ptr + len; ptr < end; ptr += tag.ber_len) {
		ptr = ber_decode_tag(&tag, ptr, end - ptr);
		if ( NULL == ptr )
			return 0;

		switch(tag.ber_tag) {
		case TAG_ADF_FCI_DF_NAME:
			if ( !autober_octet(adf_fci->df_name, &tag, ptr, &adf_fci->_df_name_count) )
				return 0;
			break;
		case TAG_ADF_FCI_ADF:
			if ( !_adf(&adf_fci->adf, ptr, tag.ber_len) )
				return 0;
			break;
		default:
			fprintf(stderr, "Unexpected tag: File Control Information: 0x%x\n", tag.ber_tag);
			continue;
		}
	}

	return 1;
}

static int _root(struct adf_fci *adf_fci,
				const uint8_t *ptr, size_t len)
{
	static const unsigned int num = AUTOBER_NUM_TAGS(root_tags);
	struct autober_constraint cons[num];
	struct gber_tag tag;
	const uint8_t *end;

	if ( !autober_constraints(root_tags, cons, num, ptr, len) ) {
		fprintf(stderr, "root_tags: constraints not satisified\n");
		return 0;
	}

	for(end = ptr + len; ptr < end; ptr += tag.ber_len) {
		ptr = ber_decode_tag(&tag, ptr, end - ptr);
		if ( NULL == ptr )
			return 0;

		switch(tag.ber_tag) {
		case TAG_ADF_FCI:
			if ( !_adf_fci(adf_fci, ptr, tag.ber_len) )
				return 0;
			break;
		default:
			fprintf(stderr, "Unexpected tag: root level: 0x%x\n", tag.ber_tag);
			continue;
		}
	}

	return 1;
}

struct adf_fci *adf_fci_decode(const uint8_t *ptr, size_t len)
{
	struct adf_fci *adf_fci;

	adf_fci = calloc(1, sizeof(*adf_fci));
	if ( NULL == adf_fci )
		return NULL;

	if ( !_root(adf_fci, ptr, len) ) {
		_free_adf_fci(adf_fci);
		return NULL;
	}

	return adf_fci;
}
