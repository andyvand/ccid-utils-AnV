#!/usr/bin/python

import os, readline, atexit
import ccid

class cmd:
	def __init__(self, func, help):
		self.__func = func
		self.__help = help
	def func(self):
		return self.__func
	def help(self):
		return self.__help

class scsh:
	def cmd_quit(self, str, *arg):
		raise SystemExit

	def cmd_help(self, str, *arg):
		self.out("You need help:")
		keys = self.__cmd.keys()
		keys.sort()
		for x in keys:
			self.out("  %-10s: %s"%(x, self.__cmd[x].help()))

	def cmd_on(self, str, *arg):
		if len(arg):
			if arg[0].upper() == "AUTO":
				v = ccid.CHIPCARD_AUTO_VOLTAGE
			elif arg[0].upper() == "5":
				v = ccid.CHIPCARD_5V
			elif arg[0].upper() == "3":
				v = ccid.CHIPCARD_3V
			elif arg[0].upper() == "1.8":
				v = ccid.CHIPCARD_1_8V
			else:
				self.out("Bad voltage: expected "
						"AUTO, 5, 3 or 1.8")
				return
		else:
			v = ccid.CHIPCARD_AUTO_VOLTAGE
		atr = self.__slot.on(v)
		if len(atr):
			self.out("Got %u bytes ATR:"%len(atr))
		ccid.hex_dump(atr)

	def cmd_off(self, str, *arg):
		self.__slot.off()

	def cmd_wait(self, str, *arg):
		self.__slot.wait_for_card()

	def cmd_rxlen(self, str, *arg):
		if len(arg):
			newrx = int(arg[0])
			if newrx != self.__rxlen:
				self.__rxlen = newrx
				self.__xfr = ccid.xfr(self.__txlen,
					self.__rxlen)

		self.out("RX_LEN = %u"%self.__rxlen)

	def cmd_txlen(self, str, *arg):
		if len(arg):
			newtx = int(arg[0])
			if newtx != self.__txlen:
				self.__txlen = newtx
				self.__xfr = ccid.xfr(self.__txlen,
					self.__txlen)

		self.out("TX_LEN = %u"%self.__txlen)

	def cmd_cla(self, str, *arg):
		if len(arg):
			self.__cla = int(arg[0], 0) & 0xff
		self.out("CLA = 0x%.2x"%self.__cla)

	def cmd_transmit(self, str, *arg):
		self.__xfr.reset()
		self.__xfr.tx_byte(self.__cla)
		for x in arg:
			self.__xfr.tx_byte(int(x, 16))
		self.__slot.transact(self.__xfr)
		self.__dump_results()

	def select_by_id(self, str, *arg):
		if len(arg) == 1 and arg[0] == "..":
			# select parent DF
			self.do_select(3, 0)
		elif len(arg):
			id = int(arg[0], 0)
			idbuf = chr(id >> 8) + chr(id & 0xff)
			self.do_select(0, 0, idbuf)
		else:
			raise ValueError, "id (..|id)"


	def select_by_name(self, str, *arg):
		try:
			name = ''
			for x in arg:
				name += chr(int(x, 16))
		except:
			name = str
		self.do_select(1<<2, 0, name)

	def select_by_path(self, str, *arg):
		raise ValueError, "Not implemented"

	def do_select(self, p1, p2, data = None):
		(sw1, sw2, foo) = self.pdu(0xa4, p1, p2, data, 0)
		del foo
		if sw1 == 0x61 or sw1 == 0x9f:
			self.pdu(0xc0, 0, 0, le = sw2)

	def cmd_select(self, str, *arg):
		if len(arg) == 0:
			raise ValueError, "(id|name|path) [optional..]"

		str = str[len(arg[0]):].lstrip()
		if arg[0] == "id":
			self.select_by_id(str, *arg[1:])
		elif arg[0] == "name":
			self.select_by_name(str, *arg[1:])
		elif arg[0] == "path":
			self.select_by_path(str, *arg[1:])
		else:
			raise ValueError, "by id name or path?"

		self.__dump_results(ber=True)

	def cmd_get(self, str, *arg):
		if not len(arg):
			raise ValueError, "Must specify data object ID"

		x = int(arg[0], 0)

		x = 0
		while x < 0x10000:
			self.__xfr.reset()
			self.__xfr.tx_byte(self.__cla)
			self.__xfr.tx_byte(0xca)
			self.__xfr.tx_byte((x >> 8))
			self.__xfr.tx_byte(x)
			self.__xfr.tx_byte(0)
			self.__slot.transact(self.__xfr)
			if self.__xfr.rx_sw1() == 0x6c:
				self.out("0x%.2x"%x)
				sw2 = self.__xfr.rx_sw2()
				self.__xfr.reset()
				self.__xfr.tx_byte(self.__cla)
				self.__xfr.tx_byte(0xca)
				self.__xfr.tx_byte((x >> 8))
				self.__xfr.tx_byte(x)
				self.__xfr.tx_byte(sw2)
				self.__slot.transact(self.__xfr)
				self.__dump_results(ber=True)
			elif self.__xfr.rx_sw1() != 0x6a and \
					self.__xfr.rx_sw1() != 0x69:
				self.__dump_results(ber=True)
			x += 1

	def cmd_challenge(self, str, *arg):
		if len(arg):
			le = int(arg[0])
		else:
			le = 8

		self.pdu(0x84, 0, 0, le = le)
		self.__dump_results()

	def cmd_read_rec(self, str, *arg):
		if len(arg) < 2:
			raise ValueError, "Must specify data object ID"

		sfi = int(arg[1])
		rec = int(arg[0])
		if len(arg) > 2:
			le = int(arg[2])
		else:
			le = 0

		(sw1, sw2, tmp) = self.pdu(0xb2, rec, (sfi << 3) | 4, le = le)
		del tmp 

		if sw1 == 0x6c or sw1 == 0x67:
			self.pdu(0xb2, rec, (sfi << 3) | 4, le = sw2)

		self.__dump_results(ber=True)


	def cmd_status(self, str, *arg):
		# clock first because it updates status
		c = self.__slot.clock_status()
		s = self.__slot.status()

		if s == ccid.CHIPCARD_ACTIVE:
			self.out("Status: ACTIVE")
		elif s == ccid.CHIPCARD_PRESENT:
			self.out("Status: PRESENT")
		elif s == ccid.CHIPCARD_NOT_PRESENT:
			self.out("Status: NOT PRESENT")

		if c == ccid.CHIPCARD_CLOCK_START:
			self.out("Clock: Running")
		elif c == ccid.CHIPCARD_CLOCK_STOP_L:
			self.out("Clock: Stopped in LO state")
		elif c == ccid.CHIPCARD_CLOCK_STOP_H:
			self.out("Clock: Stopped in HI state")
		elif c == ccid.CHIPCARD_CLOCK_STOP:
			self.out("Clock: Stopped")

	def cmd_brutecla(self, str, *arg):
		ret = {}
		i = 0
		while i < 0xff:
			self.__xfr.reset()
			self.__xfr.tx_byte(i)
			self.__xfr.tx_byte(0)
			self.__xfr.tx_byte(0)
			self.__xfr.tx_byte(0)
			self.__xfr.tx_byte(0)
			self.__slot.transact(self.__xfr)
			sw1 = self.__xfr.rx_sw1()
			if sw1 != 0x6e:
				if not ret.has_key(sw1):
					ret[sw1] = []
				ret[sw1].append(i)
			i += 1

		for x in ret.keys():
			self.out("Found %u classes, SW1 = %s (0x%.2x)"%(
					len(ret[x]), self.get_str_sw1(x), x))
			for y in ret[x]:
				self.out(" o CLA %.2x"%y)

	def cmd_brutefs(self, str, *arg):
		ret = {}
		i = 0
		while i < 0x10000:
			idbuf = chr(i >> 8) + chr(i & 0xff)
			self.do_select(0, 0, idbuf)
			sw1 = self.__xfr.rx_sw1()
			if sw1 != 0x6e and sw1 != 0x6e and sw1 != 0x94:
				if not ret.has_key(sw1):
					ret[sw1] = []
				ret[sw1].append(i)
			i += 1

		for x in ret.keys():
			self.out("Found %u objects, SW1 = %s (0x%.2x)"%(
					len(ret[x]), self.get_str_sw1(x), x))
			for y in ret[x][:200]:
				self.out(" o ID %.2x"%y)
			if len(ret[x]) > 200:
				self.out("Some results ommitted...")


	def cmd_bruteins(self, str, *arg):
		ret = {}
		i = 0
		while i < 0x100:
			# Try not to select a file incase commands are
			# file-specific.
			if i == 0xa4:
				p1 = 0xff
				p2 = 0xff
			else:
				p1 = 0
				p2 = 0
			try:
				(sw1, sw2, foo) = self.pdu(i, p1, p2, le = 0)
				del foo
			except:
				print "INS %.2x made card freak"%i
				i += 1
				continue
			if sw1 != 0x6d and sw1 != 0x6e:
				if not ret.has_key(sw1):
					ret[sw1] = []
				ret[sw1].append((i, sw2))
			i += 1

		for x in ret.keys():
			self.out("Found %u instructions, SW1 = %s (0x%.2x)"%(
					len(ret[x]), self.get_str_sw1(x), x))
			for (y,sw2) in ret[x]:
				str = self.get_str_ins(y)
				if y == None:
					str = ""
				else:
					str = " (%s)"%str

				self.out(" o INS %.2x%-22s SW2=0x%.2x"%(
					y, str, sw2))

	def get_str_ins(self, ins):
		ret = {
			0x0e: "ERASE_BINARY",
			0x20: "VERIFY",
			0x70: "MANAGE_CHANNEL",
			0x82: "EXT_AUTHENTICATE",
			0x88: "INT_AUTHENTICATE",
			0xa4: "SELECT_FILE",
			0xb0: "READ_BINARY",
			0xb2: "READ_RECORDS",
			0xb4: "GET_CHALLENGE",
			0xc0: "GET_RESPONSE",
			0xc2: "ENVELOPE",
			0xca: "GET_DATA",
			0xd0: "WRITE_BINARY",
			0xd2: "WRITE_RECORD",
			0xd6: "UPDATE_BINARY",
			0xda: "PUT_DATA",
			0xdc: "UPDATE_DATA",
			0xe2: "APPEND_RECORD"
		}
		if ret.has_key(ins):
			return ret[ins]

		if self.__cla != 0xa0:
			return None
		gsm = {
			0xa2: "GSM_SEEK",
			0x32: "GSM_INCREASE",
			0x20: "GSM_VERIFY_CHV",
			0x26: "GSM_DISABLE_CHV",
			0x28: "GSM_ENABLE_CHV",
			0x2c: "GSM_UNBLOCK_CHV",
			0x04: "GSM_INVALIDATE",
			0x44: "GSM_REHABILITATE",
			0x88: "GSM_RUN_GSM",
			0xfa: "GSM_SLEEP",
		}
		if gsm.has_key(ins):
			return gsm[ins]
		return None

	def get_str_sw1(self, sw1):
		ret = {
			0x61: "Insufficient buffer space",
			0x62: "RAM unchanged",
			0x63: "RAM changed",
			0x64: "NV-RAM unchanged",
			0x65: "NV-RAM changed",
			0x66: "Security Issues ;)",
			0x67: "Wrong length",
			0x68: "Functions in CLA not supported",
			0x69: "Permission.... DENIED",
			0x6a: "Bad parameters P1,P2",
			0x6b: "Bad parameters P1,P2",
			0x6c: "Wrong Le field",
			0x6d: "Bad INS",
			0x6e: "Bad CLA",
			0x6f: "No precise diagnosis",
			0x90: "Success" }
		if ret.has_key(sw1):
			return ret[sw1]
		else:
			return "%.2x"%sw1

	def pdu(self, ins, p1, p2, data = None, le = None):
		self.__xfr.reset()
		self.__xfr.tx_byte(self.__cla)
		self.__xfr.tx_byte(ins)
		self.__xfr.tx_byte(p1)
		self.__xfr.tx_byte(p2)
		totlen = 4
		if data != None:
			self.__xfr.tx_byte(len(data)) # Lc
			self.__xfr.tx_str(data)
			totlen += 1 + len(data)
		if  le != None:
			self.__xfr.tx_byte(le)
			totlen += 1
		while totlen < 5:
			self.__xfr.tx_byte(0)
			totlen += 1
		self.__slot.transact(self.__xfr)
		return (self.__xfr.rx_sw1(),
				self.__xfr.rx_sw2(),
				self.__xfr.rx_data())

	def __dump_results(self, ber = False):
		ret = self.__xfr.rx_data()
		self.out("SW1 = 0x%.2x : SW2 = 0x%.2x : %s (%u bytes)"%(
				self.__xfr.rx_sw1(),
				self.__xfr.rx_sw2(),
				self.get_str_sw1(self.__xfr.rx_sw1()),
				len(ret)))
		if len(ret):
			if ber:
				ccid.ber_dump(ret);
			else:
				ccid.hex_dump(ret);

	def __init__(self, tracefile=None):
		self.__cci = ccid.cci(tracefile)
		self.__slot = self.__cci.get_slot(0)
		self.__txlen = 1024
		self.__rxlen = 1024
		self.__xfr = ccid.xfr(self.__txlen, self.__rxlen)
		self.__cla = 0
		self.__cmd = {
			"status": cmd(self.cmd_status, "Slot status."),
			"slot_on": cmd(self.cmd_on, "Enable Chipcard."),
			"slot_off": cmd(self.cmd_off, "Disable Chipcard."),
			"quit": cmd(self.cmd_quit, "Quit this shit."),
			"help": cmd(self.cmd_help, "Print this message."),
			"wait": cmd(self.cmd_wait, "Wait for card."),
			"rx_len": cmd(self.cmd_rxlen, "Set RX len."),
			"tx_len": cmd(self.cmd_txlen, "Set TX len."),
			"cla": cmd(self.cmd_cla, "Set CLA."),
			"transmit": cmd(self.cmd_transmit, "Send PDU."),
			"brute_cla": cmd(self.cmd_brutecla,
						"Brute-force CLA."),
			"brute_ins": cmd(self.cmd_bruteins,
						"Brute-force INS."),
			"brute_fs": cmd(self.cmd_brutefs,
						"Brute-force DF/EF."),
			"select": cmd(self.cmd_select, "Select a file."),
			"read_rec": cmd(self.cmd_read_rec, "Read a record."),
			"challenge": cmd(self.cmd_challenge,
						"Get a NONCE for EXT. AUTH."),
			"get": cmd(self.cmd_get, "Get data object."),
			"?": cmd(self.cmd_help, "Print this message.")
		}

	def prompt(self):
		status = self.__slot.status()
		if status == ccid.CHIPCARD_NOT_PRESENT:
			return "ccid-$ "
		else:
			return "ccid-# "

	def out(self, str):
		print "ccid> " + str

	def command(self, str):
		arg = str.split()
		if len(arg) < 1:
			return
		str = str[len(arg[0]):].lstrip()
		if not self.__cmd.has_key(arg[0]):
			self.out("Unknown command: %s"%arg[0])
			return
		try:
			self.__cmd[arg[0]].func()(str, *arg[1:])
		except IOError:
			if self.__slot.status() == ccid.CHIPCARD_NOT_PRESENT:
				self.out("Card not present!!")
			else:
				pass
		except Exception, e:
			self.out("Bad Arguments: %s: %s"%(arg[0], e.message))

######### PROGRAM MAIN LOOP #########
if __name__ == '__main__':
	histfile = os.path.join(os.environ["HOME"], ".ccid-sh")
	try:
		readline.read_history_file(histfile)
	except IOError:
		pass

	atexit.register(readline.write_history_file, histfile)
	del os, histfile

	shell = scsh("ccid-sh.log")
	while True:
		try:
			str = raw_input(shell.prompt())
		except EOFError:
			print
			break

		shell.command(str);
